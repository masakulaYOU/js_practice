<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>
    
</body>
<script type="text/javascript">
	function Person(name, age, job) {
		this.name = name;
		this.age = age;
		this.job = job;
		this.sayName = function() {
			console.log(this.name);
		};
	}
	var person1 = new Person("Nicholas", 29, "Software Engineer");
	var person2 = new Person("Greg", 27, "Doctor");
	/*
	与工厂模式的不同：
	- 没有显式地创建对象
	- 直接将属性和方法赋给了this对象
	- 没有return语句
	*/
	/*
	使用new关键字调用构造函数经历的步骤：
	1. 创建一个新对象
	2. 将构造函数的作用域赋给新对象，因此this就指向了这个对象
	3. 执行构造函数中的代码
	4. 返回新对象
	*/

	/*
	constructor属性
	用于标识对象类型，但是检测对象类型还是instanceof操作符比较可靠
	*/
	console.log(person1.constructor == Person);//true
	console.log(person2.constructor == Person);//true
	console.log(person1 instanceof Object);//true
	console.log(person1 instanceof Person);//true
	console.log(person2 instanceof Object);//true
	console.log(person2 instanceof Person);//true

	/*
	将构造函数当做函数
	*/
	person1.sayName();//"Nicholas"

	Person("abc", 30, "cba");
	window.sayName();//"abc" 添加到window

	var o = new Object();
	Person.call(o,"123", 29, "321");//在o对象的作用域中调用,或者用apply
	o.sayName();//"123"


	/*
	构造函数的问题
	person1和person2的sayName函数不是同一个函数，原函数相当于
	this.sayName = new Function("console.log(this.name)")
	即不同实例上的同名函数是不相等的
	*/
	console.log(person1.sayName == person2.sayName);//false
	//也可以把函数定义转移到构造函数外面


</script>
</html>